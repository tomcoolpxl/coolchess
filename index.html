<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>coolChess</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .sidebar-title {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            letter-spacing: 2px;
            position: relative;
        }

        .info-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info-button:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .info-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            z-index: 1001;
            display: none;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .info-dialog.show {
            display: block;
        }

        .info-dialog h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .info-dialog h3 {
            color: #764ba2;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .info-dialog p {
            margin-bottom: 15px;
            line-height: 1.6;
            color: #555;
        }

        .info-dialog ul {
            margin-left: 20px;
            margin-bottom: 15px;
            line-height: 1.8;
        }

        .info-dialog li {
            margin-bottom: 8px;
            color: #555;
        }

        .info-content {
            margin-bottom: 20px;
        }

        .info-dialog button {
            width: 100%;
            margin-top: 10px;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1200px;
            display: grid;
            grid-template-columns: auto 300px;
            gap: 30px;
        }

        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .board-controls {
            width: 100%;
            max-width: 630px;
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .control-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
        }

        .control-section h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #667eea;
            font-weight: bold;
        }

        .button-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .captured-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .captured-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .captured-row strong {
            min-width: 60px;
            font-size: 14px;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            border: 3px solid #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .square {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 45px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #baca44 !important;
        }

        .square.legal-move {
            background-color: #646f40 !important;
        }

        .square.legal-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 50%;
        }

        .square.legal-capture::after {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0,0,0,0.4);
            background-color: transparent;
            border-radius: 50%;
        }

        .square.check {
            background-color: #ff6b6b !important;
        }

        .square:hover {
            opacity: 0.8;
        }

        .piece {
            user-select: none;
            pointer-events: none;
        }

        .piece-white {
            color: #ffffff !important;
        }

        .piece-black {
            color: #000000 !important;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .panel h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .status {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .status.white-turn {
            color: #666;
        }

        .status.black-turn {
            color: #222;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #667eea;
            font-size: 14px;
            margin-bottom: 10px;
            background: white;
            cursor: pointer;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .mode-buttons button {
            margin-bottom: 0;
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            font-size: 13px;
            color: #555;
            line-height: 1.6;
        }

        .move-history div {
            padding: 5px;
            border-bottom: 1px solid #ddd;
        }

        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            font-size: 24px;
        }

        .hint-text {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
            background: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .game-over {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 30px 40px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 1000;
            display: none;
            max-width: 500px;
        }

        .game-over.show {
            display: block;
        }

        .game-over h2 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #667eea;
        }

        .game-over p {
            font-size: 18px;
            margin-bottom: 30px;
            color: #555;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            z-index: 999;
        }

        .overlay.show {
            display: block;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-container label {
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }

        .board-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .evaluation-bar {
            width: 40px;
            height: 560px;
            background: #1a1a1a;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            border: 2px solid #333;
        }

        .eval-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, #f0f0f0 0%, #ffffff 100%);
            transition: height 0.5s ease;
        }

        .eval-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 3px 5px;
            border-radius: 3px;
            border: 1px solid #666;
        }

        .eval-labels {
            position: absolute;
            left: -25px;
            top: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 11px;
            font-weight: bold;
        }

        .eval-label-white {
            color: #f0f0f0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .eval-label-black {
            color: #333;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }

        .board-with-coords {
            position: relative;
        }

        .move-arrow-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 560px;
            height: 560px;
            pointer-events: none;
            z-index: 5;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }

        .move-arrow-svg.fade-out {
            opacity: 0;
        }

        .ai-thinking {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            display: flex !important;
            margin: 10px 0;
            align-items: center;
            gap: 12px;
            min-height: 49px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .ai-thinking.show {
            opacity: 1;
            visibility: visible;
        }

        .ai-thinking-spinner {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }

        .ai-thinking-text {
            font-size: 13px;
            font-weight: 500;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .coord-label {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            color: #667eea;
            user-select: none;
        }

        .coord-file {
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .coord-rank {
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .square.last-move {
            background-color: rgba(255, 170, 0, 0.15) !important;
        }

        .promotion-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            z-index: 1001;
            display: none;
        }

        .promotion-dialog.show {
            display: block;
        }

        .promotion-dialog h3 {
            margin-bottom: 20px;
            text-align: center;
            color: #333;
        }

        .promotion-pieces {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .promotion-piece {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            background: #f0f0f0;
            border: 3px solid #667eea;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }

        .promotion-piece:hover {
            transform: scale(1.1);
            background: #e0e0ff;
        }

        .move-counter {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }

        /* Hide mobile elements on desktop */
        .mobile-header {
            display: none;
        }

        .mobile-menu {
            display: none;
        }

        /* Mobile-only styles (phones) */
        @media (max-width: 600px) {
            * {
                -webkit-tap-highlight-color: transparent;
            }

            body {
                padding: 0;
                display: block;
                min-height: 100vh;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }

            /* Hide sidebar completely */
            .sidebar {
                display: none !important;
            }

            /* Hide desktop AI thinking */
            #aiThinking {
                display: none !important;
            }

            /* Mobile header - always visible */
            .mobile-header {
                display: block;
                width: 100%;
                background: white;
                position: sticky;
                top: 0;
                z-index: 100;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }

            .mobile-header-top {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 10px 15px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }

            .mobile-title {
                font-size: 20px;
                font-weight: bold;
                color: white;
                letter-spacing: 1px;
            }

            .mobile-menu-btn, .mobile-info-btn {
                width: 40px;
                height: 40px;
                background: rgba(255,255,255,0.2);
                border: 2px solid white;
                color: white;
                font-size: 18px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                margin: 0;
            }

            .mobile-menu-btn {
                border-radius: 8px;
            }

            .mobile-info-btn {
                border-radius: 50%;
            }

            .mobile-menu-btn:active, .mobile-info-btn:active {
                background: rgba(255,255,255,0.3);
                transform: scale(0.95);
            }

            .mobile-status-bar {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 10px 15px;
                background: #f8f9fa;
                border-bottom: 1px solid #ddd;
            }

            .mobile-status-bar .status {
                font-size: 14px;
                margin: 0;
            }

            .mobile-new-game-btn {
                padding: 8px 16px;
                font-size: 13px;
                margin: 0;
                width: auto;
            }

            #mobileAiThinking {
                padding: 8px 15px;
                margin: 0;
                border-radius: 0;
                font-size: 12px;
                display: flex !important;
                min-height: 36px;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s, visibility 0.3s;
            }

            #mobileAiThinking.show {
                opacity: 1;
                visibility: visible;
            }

            #mobileAiThinking .ai-thinking-spinner {
                width: 16px;
                height: 16px;
            }

            /* Mobile menu */
            .mobile-menu {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 20px;
                border-radius: 15px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                z-index: 1001;
                display: none;
                max-width: 90vw;
                max-height: 80vh;
                overflow-y: auto;
                width: 320px;
            }

            .mobile-menu.show {
                display: block;
            }

            .mobile-menu h2 {
                font-size: 20px;
                margin-bottom: 15px;
                color: #667eea;
            }

            .mobile-menu h3 {
                font-size: 14px;
                margin-bottom: 8px;
                color: #764ba2;
            }

            .mobile-menu-content {
                margin-bottom: 10px;
            }

            .mobile-menu button {
                margin-bottom: 8px;
            }

            .mobile-menu .move-history {
                max-height: 120px;
                font-size: 12px;
            }

            .mobile-menu .checkbox-container {
                margin-bottom: 0;
            }

            .mobile-menu .checkbox-container input {
                width: 24px;
                height: 24px;
            }

            .mobile-menu .checkbox-container label {
                font-size: 14px;
            }

            /* Container */
            .container {
                display: flex;
                flex-direction: column;
                padding: 0;
                width: 100%;
                max-width: 100%;
                margin: 0;
                background: transparent;
                box-shadow: none;
                border-radius: 0;
            }

            /* Board container */
            .board-container {
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 15px 10px;
                background: white;
                border-radius: 0;
            }

            /* Board scaling - smaller for phones */
            .board-wrapper {
                gap: 3px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .board-with-coords {
                position: relative;
            }

            .chessboard {
                grid-template-columns: repeat(8, 36px);
                grid-template-rows: repeat(8, 36px);
                border: 2px solid #333;
            }

            .square {
                width: 36px;
                height: 36px;
                font-size: 26px;
            }

            .square:hover {
                opacity: 1;
            }

            .square:active {
                opacity: 0.8;
            }

            /* Evaluation bar - narrower on mobile */
            .evaluation-bar {
                width: 15px;
                height: 288px;
                border: 1px solid #333;
            }

            .eval-text {
                font-size: 7px;
                padding: 2px;
                writing-mode: vertical-rl;
            }

            /* Adjust W/B labels for mobile */
            .board-wrapper > div[style*="position: relative"] > div[style*="position: absolute"] {
                font-size: 9px !important;
                left: -22px !important;
            }

            /* Coordinates */
            .coord-label {
                font-size: 8px;
            }

            .coord-file {
                bottom: -16px;
            }

            .coord-rank {
                left: -16px;
            }

            /* Move arrow */
            .move-arrow-svg {
                width: 288px;
                height: 288px;
            }

            /* Legal move indicators */
            .square.legal-move::after {
                width: 10px;
                height: 10px;
            }

            .square.legal-capture::after {
                width: 30px;
                height: 30px;
                border: 2px solid rgba(0,0,0,0.4);
            }

            /* Board controls */
            .board-controls {
                grid-template-columns: 1fr;
                gap: 10px;
                margin-top: 15px;
                width: 100%;
                max-width: 100%;
                padding: 0 5px;
                box-sizing: border-box;
            }

            .control-section {
                padding: 10px;
            }

            .control-section h3 {
                font-size: 14px;
                margin-bottom: 8px;
            }

            .captured-pieces {
                font-size: 20px;
                gap: 5px;
            }

            .captured-row strong {
                min-width: 50px;
                font-size: 13px;
            }

            .hint-text {
                font-size: 11px;
                padding: 8px;
            }

            /* Dialogs */
            .info-dialog {
                padding: 15px;
                width: 90vw;
                max-width: 90vw;
                max-height: 85vh;
            }

            .info-dialog h2 {
                font-size: 20px;
                margin-bottom: 15px;
            }

            .info-dialog h3 {
                font-size: 16px;
                margin-top: 15px;
                margin-bottom: 8px;
            }

            .info-dialog p, .info-dialog li {
                font-size: 13px;
                margin-bottom: 10px;
            }

            .game-over {
                padding: 20px;
                max-width: 90vw;
            }

            .game-over h2 {
                font-size: 24px;
                margin-bottom: 15px;
            }

            .game-over p {
                font-size: 16px;
                margin-bottom: 20px;
            }

            .promotion-dialog {
                padding: 15px;
                max-width: 90vw;
            }

            .promotion-dialog h3 {
                font-size: 16px;
                margin-bottom: 15px;
            }

            .promotion-pieces {
                gap: 10px;
            }

            .promotion-piece {
                width: 60px;
                height: 60px;
                font-size: 48px;
                border: 2px solid #667eea;
            }

            /* Buttons - ensure good touch targets */
            button {
                padding: 12px 16px;
                font-size: 14px;
                touch-action: manipulation;
                min-height: 44px;
            }

            button:hover {
                transform: none;
            }

            button:active {
                transform: scale(0.98);
            }

            select {
                padding: 12px;
                font-size: 14px;
                touch-action: manipulation;
                min-height: 44px;
            }

            /* Hide move counter on very small screens */
            .move-counter {
                font-size: 12px;
            }

            /* Force piece colors on mobile */
            .square .piece.piece-white,
            span.piece.piece-white {
                color: #ffffff !important;
                -webkit-text-fill-color: #ffffff !important;
            }

            .square .piece.piece-black,
            span.piece.piece-black {
                color: #000000 !important;
                -webkit-text-fill-color: #000000 !important;
            }
        }
    </style>
</head>
<body>
    <div class="overlay" id="overlay" onclick="handleOverlayClick()"></div>

    <div class="game-over" id="gameOver">
        <h2 id="gameOverTitle">Game Over</h2>
        <p id="gameOverMessage"></p>
        <button onclick="newGame()" aria-label="Start a new game">New Game</button>
    </div>

    <div class="promotion-dialog" id="promotionDialog">
        <h3>Choose a piece to promote to:</h3>
        <div class="promotion-pieces" id="promotionPieces"></div>
    </div>

    <div class="info-dialog" id="infoDialog">
        <h2>How coolChess Works</h2>
        <div class="info-content">
            <h3>Minimax Algorithm</h3>
            <p>The AI uses the minimax algorithm with alpha-beta pruning to evaluate moves.</p>
            <p>The algorithm works by:</p>
            <ul>
                <li>Generating all possible legal moves from the current position</li>
                <li>For each move, simulating the opponent's best response</li>
                <li>Recursively evaluating positions to a specified depth</li>
                <li>Scoring positions based on material count and piece positioning</li>
                <li>Selecting the move that maximizes the AI's position while minimizing yours</li>
            </ul>
            <p>Difficulty levels control search depth. Higher depth means the AI evaluates more moves ahead but takes longer to compute. Depth 1 evaluates only immediate moves. Depth 4 searches four moves into the future.</p>

            <h3>Opening Book</h3>
            <p>The first 2-3 moves use a pre-programmed opening book instead of calculation.</p>
            <p>Programmed moves:</p>
            <ul>
                <li>White's first move: 4 options (e4, d4, c3, Nf3)</li>
                <li>Black's response to e4: 4 options (e5, c5, e6, c6)</li>
                <li>Black's response to d4: 3 options (d5, Nf6, f6)</li>
            </ul>
            <p>Total: 11 pre-programmed moves. The AI randomly selects from available options.</p>
        </div>
        <button onclick="closeInfo()">Close</button>
    </div>

    <div class="mobile-menu" id="mobileMenu">
        <h2>Menu</h2>
        <div class="mobile-menu-content">
            <h3>Game Mode</h3>
            <div class="mode-buttons">
                <button onclick="setMode('pvp'); closeMobileMenu()" aria-label="Play against another human player">Player vs Player</button>
                <button onclick="setMode('ai'); closeMobileMenu()" aria-label="Play against the AI">Player vs AI</button>
            </div>
            <button onclick="setMode('watch'); closeMobileMenu()" style="margin-top: 10px;" aria-label="Watch two AIs play against each other">Watch AI vs AI</button>

            <h3 style="margin-top: 20px;">AI Difficulty</h3>
            <div id="mobileSingleAIDifficulty">
                <select id="mobileDifficulty" onchange="updateMobileDifficulty()">
                    <option value="1">Beginner (Depth 1)</option>
                    <option value="2" selected>Easy (Depth 2)</option>
                    <option value="3">Medium (Depth 3)</option>
                    <option value="4">Hard (Depth 4)</option>
                </select>
            </div>
            <div id="mobileWatchAIDifficulty" style="display: none;">
                <div style="margin-bottom: 10px;">
                    <label style="font-size: 13px; font-weight: bold; display: block; margin-bottom: 5px;">White AI:</label>
                    <select id="mobileDifficultyWhite" onchange="updateMobileDifficultyWhite()">
                        <option value="1">Beginner (Depth 1)</option>
                        <option value="2" selected>Easy (Depth 2)</option>
                        <option value="3">Medium (Depth 3)</option>
                        <option value="4">Hard (Depth 4)</option>
                    </select>
                </div>
                <div>
                    <label style="font-size: 13px; font-weight: bold; display: block; margin-bottom: 5px;">Black AI:</label>
                    <select id="mobileDifficultyBlack" onchange="updateMobileDifficultyBlack()">
                        <option value="1">Beginner (Depth 1)</option>
                        <option value="2" selected>Easy (Depth 2)</option>
                        <option value="3">Medium (Depth 3)</option>
                        <option value="4">Hard (Depth 4)</option>
                    </select>
                </div>
                <div id="mobileWatchControls" style="margin-top: 15px; display: flex; gap: 5px;">
                    <button id="mobileStartWatchBtn" onclick="startWatchMatch()" style="flex: 1; padding: 10px; font-size: 14px;">Start Match</button>
                    <button id="mobilePauseWatchBtn" onclick="pauseWatchMatch()" style="flex: 1; padding: 10px; font-size: 14px; display: none;">Pause</button>
                    <button id="mobileStopWatchBtn" onclick="stopWatchMatch()" style="flex: 1; padding: 10px; font-size: 14px; display: none;">Stop</button>
                </div>
            </div>

            <h3 style="margin-top: 20px;">Settings</h3>
            <div class="checkbox-container">
                <input type="checkbox" id="mobileShowLegalMoves" checked onchange="toggleMobileLegalMoves()">
                <label for="mobileShowLegalMoves">Show Legal Moves</label>
            </div>

            <h3 style="margin-top: 20px;">Move History</h3>
            <div class="move-history" id="mobileMoveHistory"></div>
        </div>
        <button onclick="closeMobileMenu()" style="margin-top: 20px;">Close</button>
    </div>

    <div class="mobile-header" id="mobileHeader">
        <div class="mobile-header-top">
            <button class="mobile-menu-btn" onclick="openMobileMenu()" aria-label="Open menu">☰</button>
            <div class="mobile-title">coolChess</div>
            <button class="mobile-info-btn" onclick="showInfo()" aria-label="Show information about how the AI works">i</button>
        </div>
        <div class="mobile-status-bar">
            <div class="status" id="mobileStatus">White's Turn</div>
            <button class="mobile-new-game-btn" onclick="newGame()" aria-label="Start a new game">New Game</button>
        </div>
        <div class="ai-thinking" id="mobileAiThinking">
            <div class="ai-thinking-spinner"></div>
            <div class="ai-thinking-text" id="mobileAiThinkingText">AI is thinking...</div>
        </div>
    </div>

    <div class="container">
        <div class="board-container">
            <div class="board-wrapper">
                <div style="position: relative;">
                    <div class="evaluation-bar">
                        <div class="eval-fill" id="evalFill"></div>
                        <div class="eval-text" id="evalText">0.0</div>
                    </div>
                    <div style="position: absolute; left: -30px; top: 5px; font-size: 11px; font-weight: bold; color: #f0f0f0; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);">W</div>
                    <div style="position: absolute; left: -30px; bottom: 5px; font-size: 11px; font-weight: bold; color: #333;">B</div>
                </div>
                <div class="board-with-coords">
                    <svg class="move-arrow-svg" id="moveArrowSvg">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                <polygon points="0 0, 10 3, 0 6" fill="rgba(255, 170, 0, 0.8)" />
                            </marker>
                        </defs>
                    </svg>
                    <div class="chessboard" id="chessboard"></div>
                </div>
            </div>

            <!-- Controls below board -->
            <div class="board-controls">
                <div class="control-section">
                    <h3>Quick Actions</h3>
                    <div class="button-row">
                        <button id="undoBtn" onclick="undoMove()" aria-label="Undo last two moves">Undo Move</button>
                        <button id="hintBtn" onclick="getHint()" aria-label="Get AI hint for best move">Get Hint</button>
                    </div>
                    <div class="hint-text" id="hintText" style="display: none;"></div>
                </div>

                <div class="control-section">
                    <h3>Captured Pieces</h3>
                    <div class="captured-container">
                        <div class="captured-row">
                            <strong>White:</strong>
                            <div class="captured-pieces" id="whiteCaptured"></div>
                        </div>
                        <div class="captured-row">
                            <strong>Black:</strong>
                            <div class="captured-pieces" id="blackCaptured"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="sidebar-title">
                coolChess
                <button class="info-button" onclick="showInfo()" title="How it works" aria-label="Show information about how the AI works">i</button>
            </div>

            <div class="panel">
                <h2>Game Status</h2>
                <div class="status" id="status">White's Turn</div>
                <div class="move-counter" id="moveCounter">Move: 1 | Halfmove: 0</div>
                <div class="ai-thinking" id="aiThinking">
                    <div class="ai-thinking-spinner"></div>
                    <div class="ai-thinking-text" id="aiThinkingText">AI is thinking...</div>
                </div>
                <div style="font-size: 12px; color: #666; margin: 10px 0; padding: 8px; background: #f5f5f5; border-radius: 5px;">
                    <strong>Eval Bar:</strong> White area (W) fills up when White is winning, Black area (B) fills when Black is winning. Number shows advantage.
                </div>
                <div class="move-history" id="moveHistory"></div>
            </div>

            <div class="panel">
                <h2>Game Mode</h2>
                <div class="mode-buttons">
                    <button onclick="setMode('pvp')" aria-label="Play against another human player">Player vs Player</button>
                    <button onclick="setMode('ai')" aria-label="Play against the AI">Player vs AI</button>
                </div>
                <button onclick="setMode('watch')" style="margin-top: 10px;" aria-label="Watch two AIs play against each other">Watch AI vs AI</button>
            </div>

            <div class="panel">
                <h2>AI Difficulty</h2>
                <div id="singleAIDifficulty">
                    <select id="difficulty" onchange="updateDifficulty()">
                        <option value="1">Beginner (Depth 1)</option>
                        <option value="2" selected>Easy (Depth 2)</option>
                        <option value="3">Medium (Depth 3)</option>
                        <option value="4">Hard (Depth 4)</option>
                    </select>
                </div>
                <div id="watchAIDifficulty" style="display: none;">
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 13px; font-weight: bold; display: block; margin-bottom: 5px;">White AI:</label>
                        <select id="difficultyWhite" onchange="updateDifficultyWhite()">
                            <option value="1">Beginner (Depth 1)</option>
                            <option value="2" selected>Easy (Depth 2)</option>
                            <option value="3">Medium (Depth 3)</option>
                            <option value="4">Hard (Depth 4)</option>
                        </select>
                    </div>
                    <div>
                        <label style="font-size: 13px; font-weight: bold; display: block; margin-bottom: 5px;">Black AI:</label>
                        <select id="difficultyBlack" onchange="updateDifficultyBlack()">
                            <option value="1">Beginner (Depth 1)</option>
                            <option value="2" selected>Easy (Depth 2)</option>
                            <option value="3">Medium (Depth 3)</option>
                            <option value="4">Hard (Depth 4)</option>
                        </select>
                    </div>
                    <div id="watchControls" style="margin-top: 15px; display: flex; gap: 5px;">
                        <button id="startWatchBtn" onclick="startWatchMatch()" style="flex: 1; padding: 8px; font-size: 12px;">Start Match</button>
                        <button id="pauseWatchBtn" onclick="pauseWatchMatch()" style="flex: 1; padding: 8px; font-size: 12px; display: none;">Pause</button>
                        <button id="stopWatchBtn" onclick="stopWatchMatch()" style="flex: 1; padding: 8px; font-size: 12px; display: none;">Stop</button>
                    </div>
                </div>
                <div style="font-size: 11px; color: #888; margin-top: 5px;">
                    Higher depth = stronger but slower
                </div>
            </div>

            <div class="panel">
                <h2>Settings</h2>
                <div class="checkbox-container">
                    <input type="checkbox" id="showLegalMoves" checked onchange="toggleLegalMoves()">
                    <label for="showLegalMoves">Show Legal Moves</label>
                </div>
                <button onclick="newGame()" aria-label="Start a new game">New Game</button>
            </div>
        </div>
    </div>

    <script>
        // Chess pieces Unicode characters
        const PIECES = {
            'K': '♚', 'Q': '♛', 'R': '♜', 'B': '♝', 'N': '♞', 'P': '♟',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        const PIECES_HOLLOW = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♔', 'q': '♕', 'r': '♖', 'b': '♗', 'n': '♘', 'p': '♙'
        };

        // Game state
        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let gameMode = 'ai';
        let aiDifficulty = 2;
        let aiDifficultyWhite = 2;
        let aiDifficultyBlack = 2;
        let showLegalMovesEnabled = true;
        let moveHistory = [];
        let capturedPieces = { white: [], black: [] };
        let gameOver = false;
        let castlingRights = { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } };
        let enPassantTarget = null;
        let halfMoveClock = 0;
        let fullMoveNumber = 1;
        let lastMove = null;
        let pendingPromotion = null;
        let arrowFadeTimeout = null;
        let arrowFadeTimeoutMove = null;
        let positionHistory = [];
        let watchMatchRunning = false;
        let gameOverReason = '';
        let gameOverDialogTimeout = null;
        let aiMoveTimeout = null;

        // Opening book - common opening moves
        const openingBook = {
            'start': [
                { from: { row: 6, col: 4 }, to: { row: 4, col: 4 } }, // e4
                { from: { row: 6, col: 3 }, to: { row: 4, col: 3 } }, // d4
                { from: { row: 6, col: 2 }, to: { row: 4, col: 2 } }, // c4 (English Opening)
                { from: { row: 7, col: 6 }, to: { row: 5, col: 5 } }  // Nf3
            ],
            'e2e4': [
                { from: { row: 1, col: 4 }, to: { row: 3, col: 4 } }, // e5
                { from: { row: 1, col: 2 }, to: { row: 3, col: 2 } }, // c5 (Sicilian)
                { from: { row: 1, col: 4 }, to: { row: 2, col: 4 } }, // e6 (French)
                { from: { row: 1, col: 2 }, to: { row: 2, col: 2 } }  // c6 (Caro-Kann)
            ],
            'd2d4': [
                { from: { row: 1, col: 3 }, to: { row: 3, col: 3 } }, // d5
                { from: { row: 0, col: 6 }, to: { row: 2, col: 5 } }, // Nf6
                { from: { row: 1, col: 5 }, to: { row: 2, col: 5 } }  // f6 (Dutch)
            ]
        };

        // Initialize the game
        function initGame() {
            board = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
            currentPlayer = 'white';
            selectedSquare = null;
            moveHistory = [];
            capturedPieces = { white: [], black: [] };
            gameOver = false;
            gameOverReason = '';
            castlingRights = { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } };
            enPassantTarget = null;
            halfMoveClock = 0;
            fullMoveNumber = 1;
            lastMove = null;
            pendingPromotion = null;
            positionHistory = [];

            // Clear SVG arrows
            const svg = document.getElementById('moveArrowSvg');
            if (svg) {
                const arrows = svg.querySelectorAll('line, circle, .hint-arrow');
                arrows.forEach(el => el.remove());
                svg.classList.remove('fade-out');
                svg.style.opacity = '1';
            }

            // Clear all timeouts
            if (arrowFadeTimeout) {
                clearTimeout(arrowFadeTimeout);
                arrowFadeTimeout = null;
            }
            arrowFadeTimeoutMove = null;

            if (gameOverDialogTimeout) {
                clearTimeout(gameOverDialogTimeout);
                gameOverDialogTimeout = null;
            }

            if (aiMoveTimeout) {
                clearTimeout(aiMoveTimeout);
                aiMoveTimeout = null;
            }

            // Ensure all overlays and dialogs are hidden
            document.getElementById('overlay').classList.remove('show');
            document.getElementById('promotionDialog').classList.remove('show');
            document.getElementById('aiThinking').classList.remove('show');
            const mobileAiThinking = document.getElementById('mobileAiThinking');
            if (mobileAiThinking) {
                mobileAiThinking.classList.remove('show');
            }

            renderBoard();
            updateStatus();
            updateCapturedPieces();
            updateEvaluationBar();
            updateMoveCounter();
            updateButtonStates();
            document.getElementById('moveHistory').innerHTML = '';
            document.getElementById('mobileMoveHistory').innerHTML = '';
            document.getElementById('hintText').style.display = 'none';
        }

        // Render the chessboard
        function renderBoard() {
            const boardWrapper = document.querySelector('.board-with-coords');
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';

            // Remove old coordinates
            document.querySelectorAll('.coord-label').forEach(el => el.remove());

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Highlight last move
                    if (lastMove &&
                        ((lastMove.from.row === row && lastMove.from.col === col) ||
                         (lastMove.to.row === row && lastMove.to.col === col))) {
                        square.classList.add('last-move');
                    }

                    const piece = board[row][col];
                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        const isWhitePiece = piece === piece.toUpperCase();
                        pieceSpan.className = isWhitePiece ? 'piece piece-white' : 'piece piece-black';
                        pieceSpan.textContent = PIECES[piece];
                        square.appendChild(pieceSpan);
                    }

                    // Add coordinates to first column and last row
                    if (col === 0) {
                        const rankLabel = document.createElement('div');
                        rankLabel.className = 'coord-label coord-rank';
                        rankLabel.textContent = 8 - row;
                        square.appendChild(rankLabel);
                    }
                    if (row === 7) {
                        const fileLabel = document.createElement('div');
                        fileLabel.className = 'coord-label coord-file';
                        fileLabel.textContent = String.fromCharCode(97 + col);
                        square.appendChild(fileLabel);
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessboard.appendChild(square);
                }
            }

            // Highlight king if in check
            if (isInCheck(currentPlayer)) {
                const kingPos = findKing(currentPlayer);
                if (kingPos) {
                    const kingSquare = document.querySelector(`[data-row="${kingPos.row}"][data-col="${kingPos.col}"]`);
                    if (kingSquare) {
                        kingSquare.classList.add('check');
                    }
                }
            }

            // Draw arrow for last move
            drawMoveArrow();
        }

        // Draw arrow showing last move
        function drawMoveArrow() {
            const svg = document.getElementById('moveArrowSvg');

            // Remove old arrows
            const oldArrows = svg.querySelectorAll('line, circle');
            oldArrows.forEach(el => el.remove());

            if (!lastMove) {
                // Clear timeout if no move to show
                if (arrowFadeTimeout) {
                    clearTimeout(arrowFadeTimeout);
                    arrowFadeTimeout = null;
                    arrowFadeTimeoutMove = null;
                }
                return;
            }

            // Check if this is a new move (different from the one we set timeout for)
            const moveKey = `${lastMove.from.row},${lastMove.from.col}->${lastMove.to.row},${lastMove.to.col}`;
            const isNewMove = moveKey !== arrowFadeTimeoutMove;

            if (isNewMove) {
                // Clear old timeout and reset opacity for new move
                if (arrowFadeTimeout) {
                    clearTimeout(arrowFadeTimeout);
                }
                svg.classList.remove('fade-out');
                svg.style.opacity = '1';
                arrowFadeTimeoutMove = moveKey;

                // Set new timeout for this move
                arrowFadeTimeout = setTimeout(() => {
                    svg.classList.add('fade-out');
                    // Remove arrows after fade completes
                    setTimeout(() => {
                        const arrows = svg.querySelectorAll('line, circle');
                        arrows.forEach(el => el.remove());
                        svg.classList.remove('fade-out');
                    }, 500); // Wait for 0.5s fade transition to complete
                }, 4000);
            }

            // Get actual square size from rendered board
            const boardSquare = document.querySelector('.square');
            const squareSize = boardSquare ? boardSquare.offsetWidth : 70;
            const fromX = lastMove.from.col * squareSize + squareSize / 2;
            const fromY = lastMove.from.row * squareSize + squareSize / 2;
            const toX = lastMove.to.col * squareSize + squareSize / 2;
            const toY = lastMove.to.row * squareSize + squareSize / 2;

            // Scale arrow elements based on square size
            const circleRadius = squareSize / 8.75; // 8 for 70px squares
            const strokeWidth = squareSize / 14; // 5 for 70px squares

            // Draw a circle at the start position
            const startCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            startCircle.setAttribute('cx', fromX);
            startCircle.setAttribute('cy', fromY);
            startCircle.setAttribute('r', circleRadius.toString());
            startCircle.setAttribute('fill', 'rgba(255, 170, 0, 0.5)');
            startCircle.setAttribute('stroke', 'rgba(255, 140, 0, 0.7)');
            startCircle.setAttribute('stroke-width', '1.5');
            svg.appendChild(startCircle);

            // Draw arrow line
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            arrow.setAttribute('x1', fromX);
            arrow.setAttribute('y1', fromY);
            arrow.setAttribute('x2', toX);
            arrow.setAttribute('y2', toY);
            arrow.setAttribute('stroke', 'rgba(255, 170, 0, 0.7)');
            arrow.setAttribute('stroke-width', strokeWidth.toString());
            arrow.setAttribute('marker-end', 'url(#arrowhead)');
            arrow.setAttribute('stroke-linecap', 'round');
            svg.appendChild(arrow);
        }

        // Handle square click
        function handleSquareClick(row, col) {
            if (gameOver) return;
            if (gameMode === 'watch') return;
            if (gameMode === 'ai' && currentPlayer === 'black') return;

            const piece = board[row][col];

            if (selectedSquare) {
                const fromRow = selectedSquare.row;
                const fromCol = selectedSquare.col;

                // Try to make the move
                if (isValidMove(fromRow, fromCol, row, col)) {
                    makeMove(fromRow, fromCol, row, col);
                    selectedSquare = null;
                    renderBoard();

                    if (!gameOver) {
                        if (gameMode === 'ai' && currentPlayer === 'black') {
                            setTimeout(makeAIMove, 500);
                        } else if (gameMode === 'watch' && watchMatchRunning && !gameOver) {
                            setTimeout(makeAIMove, 1000);
                        }
                    }
                } else {
                    // If clicking on own piece, select it instead
                    if (piece && isOwnPiece(piece, currentPlayer)) {
                        selectedSquare = { row, col };
                        renderBoard();
                        highlightLegalMoves(row, col);
                    } else {
                        selectedSquare = null;
                        renderBoard();
                    }
                }
            } else {
                // Select piece
                if (piece && isOwnPiece(piece, currentPlayer)) {
                    selectedSquare = { row, col };
                    renderBoard();
                    highlightLegalMoves(row, col);
                }
            }
        }

        // Highlight legal moves
        function highlightLegalMoves(row, col) {
            if (!showLegalMovesEnabled) return;

            const moves = getLegalMovesForPiece(row, col);
            moves.forEach(move => {
                const square = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                if (board[move.row][move.col]) {
                    square.classList.add('legal-capture');
                } else {
                    square.classList.add('legal-move');
                }
            });

            const selectedSq = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            selectedSq.classList.add('selected');
        }

        // Check if piece belongs to player
        function isOwnPiece(piece, player) {
            if (player === 'white') {
                return piece === piece.toUpperCase();
            } else {
                return piece === piece.toLowerCase();
            }
        }

        // Get all legal moves for a piece
        function getLegalMovesForPiece(row, col) {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (isValidMove(row, col, r, c)) {
                        moves.push({ row: r, col: c });
                    }
                }
            }
            return moves;
        }

        // Check if move is valid
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            // Can't move to same square
            if (fromRow === toRow && fromCol === toCol) return false;

            const piece = board[fromRow][fromCol];
            if (!piece) return false;

            // Must move own piece
            if (!isOwnPiece(piece, currentPlayer)) {
                return false;
            }

            const targetPiece = board[toRow][toCol];

            // Can't capture own piece
            if (targetPiece && isOwnPiece(targetPiece, currentPlayer)) {
                return false;
            }

            // Check piece-specific movement rules
            if (!isPieceMovementValid(piece, fromRow, fromCol, toRow, toCol)) {
                return false;
            }

            // Simulate move and check if king would be in check
            const tempBoard = JSON.parse(JSON.stringify(board));
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = '';

            const inCheck = isInCheck(currentPlayer);

            // Restore board
            board = tempBoard;

            return !inCheck;
        }

        // Validate piece movement rules
        function isPieceMovementValid(piece, fromRow, fromCol, toRow, toCol) {
            const pieceType = piece.toLowerCase();
            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;
            const direction = piece === piece.toUpperCase() ? -1 : 1; // White moves up, black moves down

            switch (pieceType) {
                case 'p': // Pawn
                    // Move forward
                    if (colDiff === 0) {
                        if (rowDiff === direction && !board[toRow][toCol]) {
                            return true;
                        }
                        // First move can be 2 squares
                        const startRow = piece === 'P' ? 6 : 1;
                        if (fromRow === startRow && rowDiff === 2 * direction &&
                            !board[toRow][toCol] && !board[fromRow + direction][fromCol]) {
                            return true;
                        }
                    }
                    // Capture diagonally
                    if (Math.abs(colDiff) === 1 && rowDiff === direction) {
                        if (board[toRow][toCol]) {
                            return true;
                        }
                        // En passant
                        if (enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                            return true;
                        }
                    }
                    return false;

                case 'r': // Rook
                    if (rowDiff === 0 || colDiff === 0) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'n': // Knight
                    return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) ||
                           (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);

                case 'b': // Bishop
                    if (Math.abs(rowDiff) === Math.abs(colDiff)) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'q': // Queen
                    if (rowDiff === 0 || colDiff === 0 || Math.abs(rowDiff) === Math.abs(colDiff)) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'k': // King
                    // Normal king move (but not staying in place)
                    if (Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1 && (rowDiff !== 0 || colDiff !== 0)) {
                        return true;
                    }
                    // Castling
                    if (rowDiff === 0 && Math.abs(colDiff) === 2) {
                        return canCastle(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                default:
                    return false;
            }
        }

        // Check if path is clear (for rook, bishop, queen)
        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : (toRow < fromRow ? -1 : 0);
            const colStep = toCol > fromCol ? 1 : (toCol < fromCol ? -1 : 0);

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) {
                    return false;
                }
                currentRow += rowStep;
                currentCol += colStep;
            }

            return true;
        }

        // Check if castling is possible
        function canCastle(fromRow, fromCol, toRow, toCol) {
            const player = currentPlayer;
            const isKingside = toCol > fromCol;

            // Check castling rights
            if (player === 'white') {
                if (isKingside && !castlingRights.white.kingside) return false;
                if (!isKingside && !castlingRights.white.queenside) return false;
            } else {
                if (isKingside && !castlingRights.black.kingside) return false;
                if (!isKingside && !castlingRights.black.queenside) return false;
            }

            // Check if king is in check
            if (isInCheck(player)) return false;

            // Check if path is clear (only between king and destination)
            const step = isKingside ? 1 : -1;
            for (let col = fromCol + step; col !== toCol; col += step) {
                if (board[fromRow][col]) return false;
            }

            // Check if king passes through or ends in check
            const originalBoard = JSON.parse(JSON.stringify(board));
            const king = player === 'white' ? 'K' : 'k';

            try {
                for (let col = fromCol; col !== toCol + step; col += step) {
                    // Create test position without mutating original
                    const testBoard = JSON.parse(JSON.stringify(originalBoard));
                    testBoard[fromRow][fromCol] = '';
                    testBoard[fromRow][col] = king;

                    // Temporarily set board for check test
                    board = testBoard;
                    if (isInCheck(player)) {
                        board = originalBoard;
                        return false;
                    }
                }
                // Restore original board
                board = originalBoard;
                return true;
            } catch (error) {
                // Ensure board is always restored on error
                board = originalBoard;
                return false;
            }
        }

        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            const pieceType = piece.toLowerCase();

            // Save old en passant target before clearing
            const oldEnPassantTarget = enPassantTarget;
            // Clear en passant target (will be set again if pawn moves two squares)
            enPassantTarget = null;

            // Detect en passant capture before saving state (use old target)
            let enPassantCapture = null;
            if (pieceType === 'p' && oldEnPassantTarget && toRow === oldEnPassantTarget.row && toCol === oldEnPassantTarget.col) {
                const capturedPawnRow = currentPlayer === 'white' ? toRow + 1 : toRow - 1;
                enPassantCapture = board[capturedPawnRow][toCol];
            }

            // Detect castling move
            const wasCastling = pieceType === 'k' && Math.abs(toCol - fromCol) === 2;

            // Save game state for undo
            moveHistory.push({
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: piece,
                captured: capturedPiece,
                enPassantCaptured: enPassantCapture,
                wasCastling: wasCastling,
                board: JSON.parse(JSON.stringify(board)),
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
                enPassantTarget: oldEnPassantTarget, // Save the old target before it was cleared
                halfMoveClock: halfMoveClock,
                fullMoveNumber: fullMoveNumber
            });

            // Update halfmove clock (for 50-move rule)
            if (pieceType === 'p' || capturedPiece) {
                halfMoveClock = 0;
            } else {
                halfMoveClock++;
            }

            // Handle en passant capture
            if (enPassantCapture) {
                const capturedPawnRow = currentPlayer === 'white' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = '';
                if (isOwnPiece(enPassantCapture, 'white')) {
                    capturedPieces.black.push(enPassantCapture);
                } else {
                    capturedPieces.white.push(enPassantCapture);
                }
            }

            // Capture piece (normal)
            if (capturedPiece) {
                if (isOwnPiece(capturedPiece, 'white')) {
                    capturedPieces.black.push(capturedPiece);
                } else {
                    capturedPieces.white.push(capturedPiece);
                }
            }

            // Handle castling - move rook
            if (pieceType === 'k' && Math.abs(toCol - fromCol) === 2) {
                const isKingside = toCol > fromCol;
                const rookFromCol = isKingside ? 7 : 0;
                const rookToCol = isKingside ? toCol - 1 : toCol + 1;
                const rook = board[fromRow][rookFromCol];
                board[fromRow][rookToCol] = rook;
                board[fromRow][rookFromCol] = '';
            }

            // Move piece
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';

            // Check for pawn promotion
            if (pieceType === 'p' && (toRow === 0 || toRow === 7)) {
                if (promotionPiece) {
                    board[toRow][toCol] = promotionPiece;
                } else {
                    // Need to show promotion dialog
                    pendingPromotion = { row: toRow, col: toCol };
                    showPromotionDialog(toRow, toCol);
                    return; // Don't continue until promotion is chosen
                }
            }

            // Set en passant target if pawn moved two squares
            if (pieceType === 'p' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = { row: (fromRow + toRow) / 2, col: toCol };
            }
            // Otherwise enPassantTarget remains null (was cleared at start of function)

            // Update castling rights when king or rook moves
            if (pieceType === 'k') {
                if (currentPlayer === 'white') {
                    castlingRights.white.kingside = false;
                    castlingRights.white.queenside = false;
                } else {
                    castlingRights.black.kingside = false;
                    castlingRights.black.queenside = false;
                }
            }
            if (pieceType === 'r') {
                if (currentPlayer === 'white') {
                    if (fromCol === 0) castlingRights.white.queenside = false;
                    if (fromCol === 7) castlingRights.white.kingside = false;
                } else {
                    if (fromCol === 0) castlingRights.black.queenside = false;
                    if (fromCol === 7) castlingRights.black.kingside = false;
                }
            }

            // Update castling rights when rook is captured
            if (capturedPiece && capturedPiece.toLowerCase() === 'r') {
                // White rooks at starting positions
                if (toRow === 7 && toCol === 0) castlingRights.white.queenside = false;
                if (toRow === 7 && toCol === 7) castlingRights.white.kingside = false;
                // Black rooks at starting positions
                if (toRow === 0 && toCol === 0) castlingRights.black.queenside = false;
                if (toRow === 0 && toCol === 7) castlingRights.black.kingside = false;
            }

            // Update last move
            lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };

            // Add to move history display (both desktop and mobile)
            // Use hollow pieces for White's moves, solid for Black's moves
            const pieceSymbol = currentPlayer === 'white' ? PIECES_HOLLOW[piece] : PIECES[piece];
            const moveNotation = `${pieceSymbol} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} → ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            const moveDiv = document.createElement('div');
            moveDiv.textContent = `${fullMoveNumber}. ${moveNotation}`;
            const mobileMoveDiv = moveDiv.cloneNode(true);
            document.getElementById('moveHistory').appendChild(moveDiv);
            document.getElementById('moveHistory').scrollTop = document.getElementById('moveHistory').scrollHeight;
            document.getElementById('mobileMoveHistory').appendChild(mobileMoveDiv);
            document.getElementById('mobileMoveHistory').scrollTop = document.getElementById('mobileMoveHistory').scrollHeight;

            // Switch player
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

            // Update fullmove number (increments after black's move)
            if (currentPlayer === 'white') {
                fullMoveNumber++;
            }

            // Track position for threefold repetition
            const positionKey = JSON.stringify(board);
            positionHistory.push(positionKey);

            // Check game over conditions
            checkGameOver();

            updateStatus();
            updateCapturedPieces();
            updateEvaluationBar();
            updateMoveCounter();
        }

        // Check if king is in check
        function isInCheck(player) {
            const kingPos = findKing(player);
            if (!kingPos) return false;

            const opponent = player === 'white' ? 'black' : 'white';

            // Check if any opponent piece can attack the king
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isOwnPiece(piece, opponent)) {
                        if (isPieceMovementValid(piece, row, col, kingPos.row, kingPos.col)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        // Find king position
        function findKing(player) {
            const kingPiece = player === 'white' ? 'K' : 'k';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        // Get all legal moves for current player
        function getAllLegalMoves(player) {
            const moves = [];
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = board[fromRow][fromCol];
                    if (piece && isOwnPiece(piece, player)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                const originalPlayer = currentPlayer;
                                currentPlayer = player;
                                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                                    moves.push({
                                        from: { row: fromRow, col: fromCol },
                                        to: { row: toRow, col: toCol }
                                    });
                                }
                                currentPlayer = originalPlayer;
                            }
                        }
                    }
                }
            }
            return moves;
        }

        // Check if game is over
        function checkGameOver() {
            const overlay = document.getElementById('overlay');
            const gameOverDiv = document.getElementById('gameOver');
            const title = document.getElementById('gameOverTitle');
            const message = document.getElementById('gameOverMessage');

            // Check for 50-move rule (100 half-moves = 50 full moves)
            if (halfMoveClock >= 100) {
                gameOver = true;
                selectedSquare = null; // Clear selection
                gameOverReason = '50-Move Rule Draw';
                title.textContent = '50-Move Rule Draw';
                message.textContent = '50 moves without a capture or pawn move. The game is a draw.';
                overlay.classList.add('show');
                gameOverDiv.classList.add('show');
                // Auto-hide after 2 seconds
                if (gameOverDialogTimeout) clearTimeout(gameOverDialogTimeout);
                gameOverDialogTimeout = setTimeout(() => {
                    overlay.classList.remove('show');
                    gameOverDiv.classList.remove('show');
                }, 2000);
                return;
            }

            // Check for threefold repetition
            if (positionHistory.length > 0) {
                const currentPosition = positionHistory[positionHistory.length - 1];
                const repetitions = positionHistory.filter(pos => pos === currentPosition).length;
                if (repetitions >= 3) {
                    gameOver = true;
                    selectedSquare = null; // Clear selection
                    gameOverReason = 'Draw by Repetition';
                    title.textContent = 'Draw by Repetition';
                    message.textContent = 'The same position occurred three times. The game is a draw.';
                    overlay.classList.add('show');
                    gameOverDiv.classList.add('show');
                    // Auto-hide after 2 seconds
                    setTimeout(() => {
                        overlay.classList.remove('show');
                        gameOverDiv.classList.remove('show');
                    }, 2000);
                    return;
                }
            }

            const moves = getAllLegalMoves(currentPlayer);

            if (moves.length === 0) {
                gameOver = true;
                selectedSquare = null; // Clear selection on game over

                if (isInCheck(currentPlayer)) {
                    // Checkmate
                    const winner = currentPlayer === 'white' ? 'Black' : 'White';
                    gameOverReason = `Checkmate - ${winner} wins!`;
                    title.textContent = 'Checkmate!';
                    message.textContent = `${winner} wins!`;
                } else {
                    // Stalemate
                    gameOverReason = 'Stalemate - Draw';
                    title.textContent = 'Stalemate!';
                    message.textContent = 'The game is a draw.';
                }

                overlay.classList.add('show');
                gameOverDiv.classList.add('show');
                // Auto-hide after 2 seconds
                if (gameOverDialogTimeout) clearTimeout(gameOverDialogTimeout);
                gameOverDialogTimeout = setTimeout(() => {
                    overlay.classList.remove('show');
                    gameOverDiv.classList.remove('show');
                }, 2000);
                updateButtonStates();
            }
        }

        // Update button states based on game mode and history
        function updateButtonStates() {
            const undoBtn = document.getElementById('undoBtn');
            const hintBtn = document.getElementById('hintBtn');

            if (undoBtn) {
                // Disable undo in watch mode or if no moves
                const canUndo = gameMode !== 'watch' && moveHistory.length > 0;
                undoBtn.disabled = !canUndo;
                undoBtn.style.opacity = canUndo ? '1' : '0.5';
                undoBtn.style.cursor = canUndo ? 'pointer' : 'not-allowed';
            }

            if (hintBtn) {
                // Disable hint in watch mode or if game over
                const canHint = gameMode !== 'watch' && !gameOver;
                hintBtn.disabled = !canHint;
                hintBtn.style.opacity = canHint ? '1' : '0.5';
                hintBtn.style.cursor = canHint ? 'pointer' : 'not-allowed';
            }
        }

        // Update status display
        function updateStatus() {
            const status = document.getElementById('status');
            const mobileStatus = document.getElementById('mobileStatus');

            let statusText = '';
            let statusClass = 'status';

            if (gameOver) {
                statusText = gameOverReason || 'Game Over';
            } else {
                // Different wording for watch mode
                if (gameMode === 'watch') {
                    statusText = `${currentPlayer === 'white' ? 'White' : 'Black'} to move`;
                } else {
                    statusText = `${currentPlayer === 'white' ? 'White' : 'Black'}'s Turn`;
                }
                statusClass = `status ${currentPlayer}-turn`;

                if (isInCheck(currentPlayer)) {
                    statusText += ' - Check!';
                }
            }

            status.textContent = statusText;
            status.className = statusClass;

            if (mobileStatus) {
                mobileStatus.textContent = statusText;
                mobileStatus.className = statusClass;
            }
        }

        // Update captured pieces display
        function updateCapturedPieces() {
            // White captures = solid, Black captures = hollow (as requested)
            document.getElementById('whiteCaptured').innerHTML =
                capturedPieces.white.map(p => PIECES[p]).join(' ');
            document.getElementById('blackCaptured').innerHTML =
                capturedPieces.black.map(p => PIECES_HOLLOW[p]).join(' ');
        }

        // Show promotion dialog
        function showPromotionDialog(row, col) {
            const isWhite = currentPlayer === 'white';
            const pieces = isWhite ? ['Q', 'R', 'B', 'N'] : ['q', 'r', 'b', 'n'];
            const dialog = document.getElementById('promotionDialog');
            const overlay = document.getElementById('overlay');
            const piecesContainer = document.getElementById('promotionPieces');

            piecesContainer.innerHTML = '';
            pieces.forEach(piece => {
                const div = document.createElement('div');
                div.className = 'promotion-piece';
                div.textContent = PIECES[piece];
                div.onclick = () => {
                    // Immediately hide dialog and overlay
                    dialog.classList.remove('show');
                    overlay.classList.remove('show');

                    // Update the promoted piece on board
                    board[row][col] = piece;
                    pendingPromotion = null;

                    // Get move info from last history entry (saved before early return)
                    if (moveHistory.length > 0) {
                        const lastHistoryMove = moveHistory[moveHistory.length - 1];
                        const fromRow = lastHistoryMove.from.row;
                        const fromCol = lastHistoryMove.from.col;
                        const originalPiece = lastHistoryMove.piece;

                        // Update last move
                        lastMove = {
                            from: { row: fromRow, col: fromCol },
                            to: { row, col }
                        };

                        // Add to move history display (both desktop and mobile)
                        const pieceSymbol = currentPlayer === 'white' ? PIECES_HOLLOW[originalPiece] : PIECES[originalPiece];
                        const moveNotation = `${pieceSymbol} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} → ${String.fromCharCode(97 + col)}${8 - row}`;
                        const moveDiv = document.createElement('div');
                        moveDiv.textContent = `${fullMoveNumber}. ${moveNotation}`;
                        const mobileMoveDiv = moveDiv.cloneNode(true);
                        document.getElementById('moveHistory').appendChild(moveDiv);
                        document.getElementById('moveHistory').scrollTop = document.getElementById('moveHistory').scrollHeight;
                        document.getElementById('mobileMoveHistory').appendChild(mobileMoveDiv);
                        document.getElementById('mobileMoveHistory').scrollTop = document.getElementById('mobileMoveHistory').scrollHeight;
                    }

                    // Switch player (this was missing!)
                    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

                    // Update fullmove number (increments after black's move)
                    if (currentPlayer === 'white') {
                        fullMoveNumber++;
                    }

                    // Track position for threefold repetition
                    const positionKey = JSON.stringify(board);
                    positionHistory.push(positionKey);

                    // Update UI
                    renderBoard();
                    updateStatus();
                    updateEvaluationBar();
                    updateMoveCounter();
                    updateCapturedPieces();

                    // Check game over
                    checkGameOver();

                    // Trigger AI move if needed
                    if (!gameOver) {
                        if (gameMode === 'ai' && currentPlayer === 'black') {
                            setTimeout(makeAIMove, 500);
                        } else if (gameMode === 'watch') {
                            setTimeout(makeAIMove, 1000);
                        }
                    }
                };
                piecesContainer.appendChild(div);
            });

            // Show dialog with overlay
            overlay.classList.add('show');
            dialog.classList.add('show');
        }

        // Update evaluation bar
        function updateEvaluationBar() {
            const evaluation = evaluateBoard();
            const maxEval = 2000;
            const normalized = Math.max(-maxEval, Math.min(maxEval, evaluation));
            const percentage = ((normalized + maxEval) / (2 * maxEval)) * 100;

            const evalFill = document.getElementById('evalFill');
            const evalText = document.getElementById('evalText');

            evalFill.style.height = percentage + '%';

            // Display evaluation from White's perspective (positive = white winning)
            const evalScore = (evaluation / 100).toFixed(1);
            if (Math.abs(evaluation) < 50) {
                evalText.textContent = '=';
                evalText.title = 'Position is equal';
            } else {
                evalText.textContent = evalScore > 0 ? `+${evalScore}` : evalScore;
                evalText.title = evalScore > 0 ? `White is winning by ${evalScore}` : `Black is winning by ${Math.abs(evalScore)}`;
            }
        }

        // Update move counter
        function updateMoveCounter() {
            const counter = document.getElementById('moveCounter');
            // More user-friendly display
            let displayText = `Move ${fullMoveNumber}`;

            // Show 50-move rule progress if getting close
            if (halfMoveClock > 20) {
                displayText += ` | Draw in ${100 - halfMoveClock} moves`;
            }

            counter.textContent = displayText;
        }

        // AI Move using Minimax algorithm
        function makeAIMove() {
            if (gameOver) return;

            // Check opening book
            if (fullMoveNumber <= 3) {
                const bookMove = getOpeningBookMove();
                if (bookMove) {
                    makeMove(bookMove.from.row, bookMove.from.col,
                            bookMove.to.row, bookMove.to.col,
                            bookMove.promotion);
                    renderBoard();

                    if (gameMode === 'watch' && watchMatchRunning && !gameOver) {
                        setTimeout(makeAIMove, 1000);
                    }
                    return;
                }
            }

            // Determine which difficulty to use
            let currentDifficulty = aiDifficulty;
            if (gameMode === 'watch') {
                currentDifficulty = currentPlayer === 'white' ? aiDifficultyWhite : aiDifficultyBlack;
            }

            // Show thinking indicator
            const thinkingDialog = document.getElementById('aiThinking');
            const thinkingText = document.getElementById('aiThinkingText');
            const mobileThinkingDialog = document.getElementById('mobileAiThinking');
            const mobileThinkingText = document.getElementById('mobileAiThinkingText');
            const difficultyNames = ['Beginner', 'Easy', 'Medium', 'Hard'];
            const difficultyName = difficultyNames[currentDifficulty - 1] || 'Unknown';
            const thinkingMessage = `${difficultyName} (depth ${currentDifficulty})`;
            thinkingText.textContent = thinkingMessage;
            thinkingDialog.classList.add('show');
            if (mobileThinkingText) {
                mobileThinkingText.textContent = thinkingMessage;
            }
            if (mobileThinkingDialog) {
                mobileThinkingDialog.classList.add('show');
            }

            // Use setTimeout to let the UI update before blocking
            setTimeout(() => {
                const startTime = Date.now();
                // CRITICAL: White maximizes (true), Black minimizes (false)
                const isMaximizing = currentPlayer === 'white';
                const bestMove = minimax(currentDifficulty, currentPlayer, -Infinity, Infinity, isMaximizing);
                const thinkTime = ((Date.now() - startTime) / 1000).toFixed(2);

                // Ensure minimum 300ms display time for thinking indicator
                const minDisplayTime = 300;
                const elapsed = Date.now() - startTime;
                const delayNeeded = Math.max(0, minDisplayTime - elapsed);

                setTimeout(() => {
                    // Hide thinking indicator
                    thinkingDialog.classList.remove('show');
                    if (mobileThinkingDialog) {
                        mobileThinkingDialog.classList.remove('show');
                    }

                    if (bestMove.move) {
                        // Check if it's a pawn promotion
                        const piece = board[bestMove.move.from.row][bestMove.move.from.col];
                        let promotionPiece = null;
                        if (piece && piece.toLowerCase() === 'p') {
                            const toRow = bestMove.move.to.row;
                            if (toRow === 0 || toRow === 7) {
                                promotionPiece = currentPlayer === 'white' ? 'Q' : 'q';
                            }
                        }

                        makeMove(bestMove.move.from.row, bestMove.move.from.col,
                                bestMove.move.to.row, bestMove.move.to.col,
                                promotionPiece);
                        renderBoard();

                        // Show think time in status
                        console.log(`AI thought for ${thinkTime} seconds`);

                        if (gameMode === 'watch' && watchMatchRunning && !gameOver) {
                            setTimeout(makeAIMove, 1000);
                        }
                    }
                }, delayNeeded);
            }, 50);
        }

        // Get move from opening book
        function getOpeningBookMove() {
            if (moveHistory.length === 0 && currentPlayer === 'white') {
                const moves = openingBook['start'];
                return moves[Math.floor(Math.random() * moves.length)];
            }

            if (moveHistory.length === 1 && currentPlayer === 'black') {
                const lastMove = moveHistory[0];
                const key = `${String.fromCharCode(97 + lastMove.from.col)}${8 - lastMove.from.row}${String.fromCharCode(97 + lastMove.to.col)}${8 - lastMove.to.row}`;
                const moves = openingBook[key];
                if (moves) {
                    return moves[Math.floor(Math.random() * moves.length)];
                }
            }

            return null;
        }

        // Minimax algorithm with alpha-beta pruning
        function minimax(depth, player, alpha, beta, isMaximizing) {
            if (depth === 0) {
                return { score: evaluateBoard() };
            }

            const moves = getAllLegalMoves(player);

            if (moves.length === 0) {
                const originalPlayer = currentPlayer;
                currentPlayer = player;
                if (isInCheck(player)) {
                    currentPlayer = originalPlayer;
                    return { score: isMaximizing ? -10000 : 10000 };
                }
                currentPlayer = originalPlayer;
                return { score: 0 }; // Stalemate
            }

            let bestMove = null;

            if (isMaximizing) {
                let maxScore = -Infinity;

                for (const move of moves) {
                    // Save game state
                    const originalBoard = JSON.parse(JSON.stringify(board));
                    const originalCurrentPlayer = currentPlayer;
                    const originalCastlingRights = JSON.parse(JSON.stringify(castlingRights));
                    const originalEnPassantTarget = enPassantTarget;

                    try {
                        currentPlayer = player;
                        board[move.to.row][move.to.col] = board[move.from.row][move.from.col];
                        board[move.from.row][move.from.col] = '';

                        const nextPlayer = player === 'white' ? 'black' : 'white';
                        const result = minimax(depth - 1, nextPlayer, alpha, beta, false);

                        if (result.score > maxScore) {
                            maxScore = result.score;
                            bestMove = move;
                        }

                        alpha = Math.max(alpha, result.score);
                        if (beta <= alpha) {
                            break; // Beta cutoff (finally block will restore state)
                        }
                    } finally {
                        // Always restore game state
                        board = originalBoard;
                        currentPlayer = originalCurrentPlayer;
                        castlingRights = originalCastlingRights;
                        enPassantTarget = originalEnPassantTarget;
                    }
                }

                return { score: maxScore, move: bestMove };
            } else {
                let minScore = Infinity;

                for (const move of moves) {
                    // Save game state
                    const originalBoard = JSON.parse(JSON.stringify(board));
                    const originalCurrentPlayer = currentPlayer;
                    const originalCastlingRights = JSON.parse(JSON.stringify(castlingRights));
                    const originalEnPassantTarget = enPassantTarget;

                    try {
                        currentPlayer = player;
                        board[move.to.row][move.to.col] = board[move.from.row][move.from.col];
                        board[move.from.row][move.from.col] = '';

                        const nextPlayer = player === 'white' ? 'black' : 'white';
                        const result = minimax(depth - 1, nextPlayer, alpha, beta, true);

                        if (result.score < minScore) {
                            minScore = result.score;
                            bestMove = move;
                        }

                        beta = Math.min(beta, result.score);
                        if (beta <= alpha) {
                            break; // Alpha cutoff (finally block will restore state)
                        }
                    } finally {
                        // Always restore game state
                        board = originalBoard;
                        currentPlayer = originalCurrentPlayer;
                        castlingRights = originalCastlingRights;
                        enPassantTarget = originalEnPassantTarget;
                    }
                }

                return { score: minScore, move: bestMove };
            }
        }

        // Evaluate board position
        function evaluateBoard(depth = 0) {
            const pieceValues = {
                'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000,
                'P': 100, 'N': 320, 'B': 330, 'R': 500, 'Q': 900, 'K': 20000
            };

            // Piece-square tables for positional bonuses
            const pawnTable = [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10,  5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ];

            const knightTable = [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ];

            const bishopTable = [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10, 10, 10, 10, 10, 10, 10,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ];

            const rookTable = [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [5, 10, 10, 10, 10, 10, 10,  5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [0,  0,  0,  5,  5,  0,  0,  0]
            ];

            const queenTable = [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [-5,  0,  5,  5,  5,  5,  0, -5],
                [0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ];

            const kingMiddleGameTable = [
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [20, 20,  0,  0,  0,  0, 20, 20],
                [20, 30, 10,  0,  0, 10, 30, 20]
            ];

            function getPieceSquareValue(piece, row, col) {
                const isWhite = piece === piece.toUpperCase();
                const r = isWhite ? row : 7 - row;

                switch(piece.toLowerCase()) {
                    case 'p': return pawnTable[r][col];
                    case 'n': return knightTable[r][col];
                    case 'b': return bishopTable[r][col];
                    case 'r': return rookTable[r][col];
                    case 'q': return queenTable[r][col];
                    case 'k': return kingMiddleGameTable[r][col];
                    default: return 0;
                }
            }

            let score = 0;
            let whiteMoves = 0;
            let blackMoves = 0;

            // Material and position evaluation
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const value = pieceValues[piece];
                        const posValue = getPieceSquareValue(piece, row, col);

                        if (piece === piece.toUpperCase()) {
                            score += value + posValue;
                        } else {
                            score -= value + posValue;
                        }
                    }
                }
            }

            // Mobility evaluation (number of legal moves)
            const originalPlayer = currentPlayer;

            currentPlayer = 'white';
            whiteMoves = getAllLegalMoves('white').length;

            currentPlayer = 'black';
            blackMoves = getAllLegalMoves('black').length;

            currentPlayer = originalPlayer;
            score += (whiteMoves - blackMoves) * 10;

            // King safety - penalize if king is in check
            if (isInCheck('white')) score -= 50;
            if (isInCheck('black')) score += 50;

            return score;
        }

        // Get hint for current player
        // Draw hint arrow in different color
        function drawHintArrow(fromRow, fromCol, toRow, toCol) {
            const svg = document.getElementById('moveArrowSvg');

            // Get actual square size from rendered board
            const boardSquare = document.querySelector('.square');
            const squareSize = boardSquare ? boardSquare.offsetWidth : 70;
            const fromX = fromCol * squareSize + squareSize / 2;
            const fromY = fromRow * squareSize + squareSize / 2;
            const toX = toCol * squareSize + squareSize / 2;
            const toY = toRow * squareSize + squareSize / 2;

            // Create arrow line (red color with dotted line for hint)
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', fromX);
            line.setAttribute('y1', fromY);
            line.setAttribute('x2', toX);
            line.setAttribute('y2', toY);
            line.setAttribute('stroke', '#FF0000');
            line.setAttribute('stroke-width', '4');
            line.setAttribute('stroke-linecap', 'round');
            line.setAttribute('stroke-dasharray', '8,4');
            line.setAttribute('marker-end', 'url(#arrowhead-hint)');
            line.classList.add('hint-arrow');

            // Create start circle (red)
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', fromX);
            circle.setAttribute('cy', fromY);
            circle.setAttribute('r', '6');
            circle.setAttribute('fill', '#FF0000');
            circle.classList.add('hint-arrow');

            // Create arrowhead marker for hint if it doesn't exist
            if (!svg.querySelector('#arrowhead-hint')) {
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'arrowhead-hint');
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '10');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3');
                marker.setAttribute('orient', 'auto');
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3, 0 6');
                polygon.setAttribute('fill', '#FF0000');
                marker.appendChild(polygon);
                defs.appendChild(marker);
                svg.appendChild(defs);
            }

            svg.appendChild(line);
            svg.appendChild(circle);

            // Fade out and remove after 1.5 seconds
            setTimeout(() => {
                svg.classList.add('fade-out');
                setTimeout(() => {
                    const hintArrows = svg.querySelectorAll('.hint-arrow');
                    hintArrows.forEach(el => el.remove());
                    svg.classList.remove('fade-out');
                    svg.style.opacity = '1';
                }, 500); // Wait for fade transition
            }, 1500);
        }

        function getHint() {
            if (gameOver) return;
            if (gameMode === 'watch') return;

            const hintBtn = document.getElementById('hintBtn');
            const hintText = document.getElementById('hintText');

            // Disable button during calculation
            if (hintBtn) {
                hintBtn.disabled = true;
                hintBtn.style.opacity = '0.5';
                hintBtn.style.cursor = 'not-allowed';
            }

            hintText.style.display = 'block';
            hintText.textContent = 'Calculating best move...';

            setTimeout(() => {
                const bestMove = minimax(Math.min(aiDifficulty, 2), currentPlayer, -Infinity, Infinity, currentPlayer === 'white');

                if (bestMove.move) {
                    const piece = board[bestMove.move.from.row][bestMove.move.from.col];
                    const fromSquare = String.fromCharCode(97 + bestMove.move.from.col) + (8 - bestMove.move.from.row);
                    const toSquare = String.fromCharCode(97 + bestMove.move.to.col) + (8 - bestMove.move.to.row);

                    hintText.textContent = `Suggested move: ${PIECES[piece]} from ${fromSquare} to ${toSquare}`;

                    // Draw hint arrow
                    drawHintArrow(bestMove.move.from.row, bestMove.move.from.col,
                                 bestMove.move.to.row, bestMove.move.to.col);
                } else {
                    hintText.textContent = 'No legal moves available.';
                }

                // Re-enable button
                if (hintBtn) {
                    hintBtn.disabled = false;
                    hintBtn.style.opacity = '1';
                    hintBtn.style.cursor = 'pointer';
                }
            }, 100);
        }

        // Game controls
        function newGame() {
            // Ask for confirmation if game is in progress (moves have been made)
            if (moveHistory.length > 0 && !gameOver) {
                if (!confirm('Start a new game? Current game will be lost.')) {
                    return;
                }
            }

            document.getElementById('overlay').classList.remove('show');
            document.getElementById('gameOver').classList.remove('show');
            initGame();

            // Reset watch mode controls if in watch mode
            if (gameMode === 'watch') {
                watchMatchRunning = false;
                document.getElementById('startWatchBtn').style.display = 'block';
                document.getElementById('pauseWatchBtn').style.display = 'none';
                document.getElementById('stopWatchBtn').style.display = 'none';
                document.getElementById('pauseWatchBtn').textContent = 'Pause';

                const mobileStartBtn = document.getElementById('mobileStartWatchBtn');
                const mobilePauseBtn = document.getElementById('mobilePauseWatchBtn');
                const mobileStopBtn = document.getElementById('mobileStopWatchBtn');
                if (mobileStartBtn) mobileStartBtn.style.display = 'block';
                if (mobilePauseBtn) {
                    mobilePauseBtn.style.display = 'none';
                    mobilePauseBtn.textContent = 'Pause';
                }
                if (mobileStopBtn) mobileStopBtn.style.display = 'none';
            }
        }

        function undoSingleMove() {
            if (moveHistory.length === 0) return false;

            const lastMoveData = moveHistory.pop();
            board = lastMoveData.board;
            castlingRights = lastMoveData.castlingRights;
            enPassantTarget = lastMoveData.enPassantTarget;
            halfMoveClock = lastMoveData.halfMoveClock;
            fullMoveNumber = lastMoveData.fullMoveNumber;
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

            // Clean up position history
            if (positionHistory.length > 0) {
                positionHistory.pop();
            }

            // Update captured pieces (normal captures)
            if (lastMoveData.captured) {
                const capturedBy = isOwnPiece(lastMoveData.captured, 'white') ? 'black' : 'white';
                const index = capturedPieces[capturedBy].indexOf(lastMoveData.captured);
                if (index > -1) {
                    capturedPieces[capturedBy].splice(index, 1);
                }
            }

            // Update captured pieces (en passant)
            if (lastMoveData.enPassantCaptured) {
                const capturedBy = isOwnPiece(lastMoveData.enPassantCaptured, 'white') ? 'black' : 'white';
                const index = capturedPieces[capturedBy].indexOf(lastMoveData.enPassantCaptured);
                if (index > -1) {
                    capturedPieces[capturedBy].splice(index, 1);
                }
            }

            // Update last move
            if (moveHistory.length > 0) {
                lastMove = {
                    from: moveHistory[moveHistory.length - 1].from,
                    to: moveHistory[moveHistory.length - 1].to
                };
            } else {
                lastMove = null;
            }

            const moveHistoryDiv = document.getElementById('moveHistory');
            if (moveHistoryDiv.lastChild) {
                moveHistoryDiv.removeChild(moveHistoryDiv.lastChild);
            }

            const mobileMoveHistoryDiv = document.getElementById('mobileMoveHistory');
            if (mobileMoveHistoryDiv.lastChild) {
                mobileMoveHistoryDiv.removeChild(mobileMoveHistoryDiv.lastChild);
            }

            return true;
        }

        function undoMove() {
            // Don't allow undo in AI vs AI watch mode
            if (gameMode === 'watch') {
                return;
            }

            // Undo 2 moves (opponent's move + your move) to get back to your turn
            if (moveHistory.length < 2) {
                // If less than 2 moves, just undo 1
                if (!undoSingleMove()) return;
            } else {
                // Undo opponent's move
                if (!undoSingleMove()) return;
                // Undo your move
                if (!undoSingleMove()) return;
            }

            gameOver = false;
            gameOverReason = '';
            document.getElementById('overlay').classList.remove('show');
            document.getElementById('gameOver').classList.remove('show');

            renderBoard();
            updateStatus();
            updateCapturedPieces();
            updateEvaluationBar();
            updateMoveCounter();
            updateButtonStates();
        }

        function showInfo() {
            document.getElementById('overlay').classList.add('show');
            document.getElementById('infoDialog').classList.add('show');
        }

        function closeInfo() {
            document.getElementById('overlay').classList.remove('show');
            document.getElementById('infoDialog').classList.remove('show');
        }

        function setMode(mode) {
            gameMode = mode;

            // Show/hide appropriate difficulty selectors (desktop)
            const singleDiff = document.getElementById('singleAIDifficulty');
            const watchDiff = document.getElementById('watchAIDifficulty');

            // Show/hide appropriate difficulty selectors (mobile)
            const mobileSingleDiff = document.getElementById('mobileSingleAIDifficulty');
            const mobileWatchDiff = document.getElementById('mobileWatchAIDifficulty');

            if (mode === 'watch') {
                singleDiff.style.display = 'none';
                watchDiff.style.display = 'block';
                if (mobileSingleDiff) mobileSingleDiff.style.display = 'none';
                if (mobileWatchDiff) mobileWatchDiff.style.display = 'block';

                // Stop any running match and show Start button
                watchMatchRunning = false;
                document.getElementById('startWatchBtn').style.display = 'block';
                document.getElementById('pauseWatchBtn').style.display = 'none';
                document.getElementById('stopWatchBtn').style.display = 'none';
                const mobileStartBtn = document.getElementById('mobileStartWatchBtn');
                const mobilePauseBtn = document.getElementById('mobilePauseWatchBtn');
                const mobileStopBtn = document.getElementById('mobileStopWatchBtn');
                if (mobileStartBtn) mobileStartBtn.style.display = 'block';
                if (mobilePauseBtn) mobilePauseBtn.style.display = 'none';
                if (mobileStopBtn) mobileStopBtn.style.display = 'none';
            } else {
                singleDiff.style.display = 'block';
                watchDiff.style.display = 'none';
                if (mobileSingleDiff) mobileSingleDiff.style.display = 'block';
                if (mobileWatchDiff) mobileWatchDiff.style.display = 'none';
                watchMatchRunning = false;
            }

            // Clear any pending promotion before mode change
            pendingPromotion = null;
            document.getElementById('overlay').classList.remove('show');
            document.getElementById('promotionDialog').classList.remove('show');

            newGame();
            updateButtonStates();
        }

        function startWatchMatch() {
            if (gameMode !== 'watch') return;
            if (watchMatchRunning) return; // Already running

            watchMatchRunning = true;

            // Update button visibility (desktop)
            document.getElementById('startWatchBtn').style.display = 'none';
            document.getElementById('pauseWatchBtn').style.display = 'block';
            document.getElementById('stopWatchBtn').style.display = 'block';

            // Update button visibility (mobile)
            const mobileStartBtn = document.getElementById('mobileStartWatchBtn');
            const mobilePauseBtn = document.getElementById('mobilePauseWatchBtn');
            const mobileStopBtn = document.getElementById('mobileStopWatchBtn');
            if (mobileStartBtn) mobileStartBtn.style.display = 'none';
            if (mobilePauseBtn) mobilePauseBtn.style.display = 'block';
            if (mobileStopBtn) mobileStopBtn.style.display = 'block';

            // Start the match
            setTimeout(makeAIMove, 500);
        }

        function pauseWatchMatch() {
            if (gameMode !== 'watch') return;

            watchMatchRunning = !watchMatchRunning;

            // Update button text (desktop)
            const pauseBtn = document.getElementById('pauseWatchBtn');
            pauseBtn.textContent = watchMatchRunning ? 'Pause' : 'Resume';

            // Update button text (mobile)
            const mobilePauseBtn = document.getElementById('mobilePauseWatchBtn');
            if (mobilePauseBtn) {
                mobilePauseBtn.textContent = watchMatchRunning ? 'Pause' : 'Resume';
            }

            // Resume if needed
            if (watchMatchRunning) {
                setTimeout(makeAIMove, 500);
            }
        }

        function stopWatchMatch() {
            if (gameMode !== 'watch') return;

            watchMatchRunning = false;

            // Update button visibility (desktop)
            document.getElementById('startWatchBtn').style.display = 'block';
            document.getElementById('pauseWatchBtn').style.display = 'none';
            document.getElementById('stopWatchBtn').style.display = 'none';

            // Update button visibility (mobile)
            const mobileStartBtn = document.getElementById('mobileStartWatchBtn');
            const mobilePauseBtn = document.getElementById('mobilePauseWatchBtn');
            const mobileStopBtn = document.getElementById('mobileStopWatchBtn');
            if (mobileStartBtn) mobileStartBtn.style.display = 'block';
            if (mobilePauseBtn) mobilePauseBtn.style.display = 'none';
            if (mobileStopBtn) mobileStopBtn.style.display = 'none';

            // Reset pause button text
            document.getElementById('pauseWatchBtn').textContent = 'Pause';
            if (mobilePauseBtn) mobilePauseBtn.textContent = 'Pause';

            // Reset the game
            newGame();
        }

        function updateDifficulty() {
            aiDifficulty = parseInt(document.getElementById('difficulty').value);
            // Sync to mobile
            const mobileDifficulty = document.getElementById('mobileDifficulty');
            if (mobileDifficulty) mobileDifficulty.value = aiDifficulty;
        }

        function updateDifficultyWhite() {
            aiDifficultyWhite = parseInt(document.getElementById('difficultyWhite').value);
            // Sync to mobile
            const mobileDifficultyWhite = document.getElementById('mobileDifficultyWhite');
            if (mobileDifficultyWhite) mobileDifficultyWhite.value = aiDifficultyWhite;
        }

        function updateDifficultyBlack() {
            aiDifficultyBlack = parseInt(document.getElementById('difficultyBlack').value);
            // Sync to mobile
            const mobileDifficultyBlack = document.getElementById('mobileDifficultyBlack');
            if (mobileDifficultyBlack) mobileDifficultyBlack.value = aiDifficultyBlack;
        }

        function updateMobileDifficulty() {
            aiDifficulty = parseInt(document.getElementById('mobileDifficulty').value);
            // Sync to desktop
            document.getElementById('difficulty').value = aiDifficulty;
        }

        function updateMobileDifficultyWhite() {
            aiDifficultyWhite = parseInt(document.getElementById('mobileDifficultyWhite').value);
            // Sync to desktop
            document.getElementById('difficultyWhite').value = aiDifficultyWhite;
        }

        function updateMobileDifficultyBlack() {
            aiDifficultyBlack = parseInt(document.getElementById('mobileDifficultyBlack').value);
            // Sync to desktop
            document.getElementById('difficultyBlack').value = aiDifficultyBlack;
        }

        function toggleLegalMoves() {
            showLegalMovesEnabled = document.getElementById('showLegalMoves').checked;
            // Sync to mobile
            const mobileCheckbox = document.getElementById('mobileShowLegalMoves');
            if (mobileCheckbox) mobileCheckbox.checked = showLegalMovesEnabled;
            renderBoard();
        }

        function toggleMobileLegalMoves() {
            showLegalMovesEnabled = document.getElementById('mobileShowLegalMoves').checked;
            // Sync to desktop
            document.getElementById('showLegalMoves').checked = showLegalMovesEnabled;
            renderBoard();
        }

        // Handle overlay click to close certain dialogs
        function handleOverlayClick() {
            // Only close mobile menu and info dialog on overlay click
            // Don't close game over or promotion dialogs (require explicit button)
            const mobileMenu = document.getElementById('mobileMenu');
            const infoDialog = document.getElementById('infoDialog');

            if (mobileMenu && mobileMenu.classList.contains('show')) {
                closeMobileMenu();
            } else if (infoDialog && infoDialog.classList.contains('show')) {
                closeInfo();
            }
        }

        // Mobile menu functions
        function openMobileMenu() {
            document.getElementById('overlay').classList.add('show');
            document.getElementById('mobileMenu').classList.add('show');
        }

        function closeMobileMenu() {
            document.getElementById('overlay').classList.remove('show');
            document.getElementById('mobileMenu').classList.remove('show');
        }


        // Initialize game on load
        initGame();
    </script>
</body>
</html>
